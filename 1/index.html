<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Datrevil</title>
    <!-- Sugerencias de recursos CDN: establece conexiones tempranas con servidores externos -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">

    <!-- Tipografía premium vía Google Fonts CDN -->
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">

    <!-- Instrucciones de caché del navegador -->
    <meta http-equiv="Cache-Control" content="max-age=31536000">

    <!-- Previsualización en redes sociales (Open Graph) -->
    <meta property="og:title" content="Datrevil">
    <meta property="og:description" content="Libermetal">
    <meta property="og:image" content="https://datrevil.page.gd/favicon.png">
    <meta property="og:url" content="https://datrevil.page.gd/">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary">

    <!-- Precarga de recursos pesados para que estén listos antes de que comience la animación -->
    <link rel="preload" href="dark_bg.png" as="image">
    <link rel="preload" href="logo.webp" as="image">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Metal Mania', cursive;
        }

        /* Capa de fondo — abismo infernal */
        .abyss-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-image: url('dark_bg.png');
            background-size: cover;
            background-position: center bottom;
            filter: brightness(0.65) contrast(1.4) saturate(1.2);
            opacity: 0;
            transition: opacity 3s ease-out;
            animation: kenBurns 40s linear infinite alternate;
            will-change: transform;
        }

        .abyss-bg.loaded {
            opacity: 1;
        }

        @keyframes kenBurns {
            0% {
                transform: scale(1.0);
            }

            100% {
                transform: scale(1.15);
            }
        }

        /* Capa de viñeta superpuesta */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(10, 0, 0, 0.1) 20%, rgba(5, 0, 0, 0.95) 100%);
            z-index: 3;
            pointer-events: none;
        }

        /* Capa de brasas al frente */
        #embers-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            will-change: transform;
            opacity: 0.85;
            mix-blend-mode: screen;
            /* Capa del compositor GPU */
        }

        /* Contenedor del logo */
        .logo-container {
            position: relative;
            z-index: 4;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Envoltura para el flotado continuo */
        .logo-floater {
            position: relative;
            display: inline-block;
            animation: logoFloat 6s ease-in-out infinite;
            will-change: transform;
        }

        /* Imagen del logo */
        .logo-inner {
            max-width: 600px;
            width: 80vw;
            height: auto;
            opacity: 0;
            transform: scale(0.92);
            filter: blur(8px) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
            /* Se usa transición en lugar de animación para disparar al cargar individualmente */
            transition: opacity 3s cubic-bezier(0.2, 0.8, 0.2, 1),
                transform 3s cubic-bezier(0.2, 0.8, 0.2, 1),
                filter 3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .logo-inner.loaded {
            opacity: 1;
            transform: scale(1);
            filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
        }

        @keyframes logoEnter {
            to {
                opacity: 1;
                transform: scale(1);
                filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
            }
        }

        @keyframes logoFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-12px);
            }
        }

        /* Estilos de los ojos */
        .eyes-wrapper {
            position: absolute;
            z-index: -1;
            top: 68%;
            left: 49%;
            transform: translate(-50%, -50%) scale(0.16);
            opacity: 0;
            filter: blur(8px) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 130px;
            /* Espacio entre los dos ojos */
            pointer-events: none;
        }

        /* Activado por JS una vez que el logo ha aparecido */
        .eyes-wrapper.animate {
            animation: eyesEnter 3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        @keyframes eyesEnter {
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0.22);
                filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
            }
        }

        /* Panel oscuro detrás de los ojos — definido aquí para que las media queries lo sobreescriban */
        .eyes-wrapper::before {
            content: '';
            position: absolute;
            inset: -30px 0 0 0;
            background: #050505;
            border-radius: 0 0 50% 50%;
            z-index: -1;
        }

        /* ── Ojos responsivos ─────────────────────────────────────── */
        /* Tablets */
        @media (max-width: 900px) {
            .eyes-wrapper {
                transform: translate(-50%, -50%) scale(0.13);
                gap: 180px;
            }

            @keyframes eyesEnter {
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(0.175);
                    filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
                }
            }

            .eyes-wrapper::before {
                inset: -50px -70px;
            }
        }

        /* Celulares */
        @media (max-width: 600px) {
            .eyes-wrapper {
                transform: translate(-50%, -50%) scale(0.08);
                gap: 120px;
            }

            @keyframes eyesEnter {
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(0.115);
                    filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
                }
            }

            .eyes-wrapper::before {
                inset: -35px -50px;
            }
        }

        /* Celulares pequeños */
        @media (max-width: 400px) {
            .eyes-wrapper {
                transform: translate(-50%, -50%) scale(0.065);
                gap: 80px;
            }

            @keyframes eyesEnter {
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(0.095);
                    filter: blur(0) drop-shadow(0 0 20px rgba(0, 0, 0, 0.6));
                }
            }

            .eyes-wrapper::before {
                inset: -25px -35px;
            }
        }

        /* El escalado por ojo también aplica si es necesario, pero el escalado de la envoltura lo maneja limpiamente */
        .eye-container {
            position: relative;
            width: 400px;
            height: 400px;
            overflow: hidden;
            pointer-events: auto;
            /* Rotación pronunciada para aspecto amenazante */
            transform: rotate(30deg);
        }

        .eye-container:nth-child(2) {
            transform: rotate(-30deg);
        }

        .eye {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 160px;
            height: 160px;
            border-radius: 160px 0;
            background: #ab1f1f;
            /* Base rojiza para coincidir con la calavera de fuego */
            overflow: hidden;
            transition: all 0.5s ease-in-out;
            box-shadow: inset 0 0 20px #000;
        }

        .eye .ball {
            position: absolute;
            width: 110px;
            height: 110px;
            border-radius: 50%;
            background: #ff5500;
            /* Base naranja brillante para el ojo de gato */
            top: 25px;
            left: 25px;
            transform: rotate(-45deg);
            /* Estado predeterminado para mantener la ranura recta */
            box-shadow: inset 0 0 25px #4a0000;
            /* Bordes rojo profundo en el iris */
        }

        .eye .ball .iris {
            position: absolute;
            width: 12px;
            height: 60px;
            /* Pupila vertical tipo rendija */
            border-radius: 50%;
            background: #000000;
            /* Pupila totalmente negra */
            top: 25px;
            left: 49px;
            /* Centro horizontal: (110 - 12)/2 = 49 */
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
            /* Borde rojo brillante a lo largo de la rendija */
        }

        .lid-top {
            position: absolute;
            z-index: 2;
            width: 240px;
            height: 106px;
            top: 125px;
            left: 80px;
            background: #050505;
            /* Sombra negra superpuesta */
            transform: translateY(-60px);
            animation: lid-top 5s ease-in-out infinite;
            border-radius: 0 0 20px 20px;
        }

        .lid-bottom {
            position: absolute;
            z-index: 2;
            width: 240px;
            height: 106px;
            bottom: 125px;
            left: 80px;
            background: #050505;
            /* Sombra negra superpuesta */
            transform: rotate(180deg) translateY(-60px);
            animation: lid-bottom 5s ease-in-out infinite;
            border-radius: 0 0 20px 20px;
        }

        .eye-container:hover .lid-top {
            transform: translateY(15px);
        }

        .eye-container:hover .lid-bottom {
            transform: rotate(180deg) translateY(15px);
        }

        @keyframes lid-top {

            0%,
            20%,
            26%,
            60%,
            66%,
            100% {
                transform: translateY(-70px);
                /* Completamente abierto */
            }

            23%,
            63% {
                transform: translateY(20px);
                /* Parpadeo deliberado y suave */
            }
        }

        @keyframes lid-bottom {

            0%,
            20%,
            26%,
            60%,
            66%,
            100% {
                transform: rotate(180deg) translateY(-70px);
                /* Completamente abierto */
            }

            23%,
            63% {
                transform: rotate(180deg) translateY(20px);
                /* Parpadeo deliberado y suave */
            }
        }
    </style>
</head>

<body>

    <div class="abyss-bg"></div>
    <div class="overlay"></div>
    <canvas id="embers-canvas"></canvas>

    <div class="logo-container">
        <div class="logo-floater">
            <div class="eyes-wrapper">
                <div class="eye-container">
                    <div class="eye">
                        <div class="ball">
                            <div class="iris"></div>
                        </div>
                    </div>
                    <div class="lid-top"></div>
                    <div class="lid-bottom"></div>
                </div>
                <div class="eye-container">
                    <div class="eye">
                        <div class="ball">
                            <div class="iris"></div>
                        </div>
                    </div>
                    <div class="lid-top"></div>
                    <div class="lid-bottom"></div>
                </div>
            </div>
            <img src="logo.webp" alt="Logo" class="logo-inner" id="logo">
        </div>
    </div>

    <script>
        const embersCanvas = document.getElementById('embers-canvas');
        const embersCtx = embersCanvas.getContext('2d');

        let width, height;
        let embersParticles = [];
        let frameCount = 0;
        let lastFrameTime = 0;      // límite de 30fps
        const FRAME_MS = 1000 / 30; // objetivo: 30fps

        const embersCount = 80;    // Cantidad de brasas flotantes reducida para rendimiento

        // Lógica de seguimiento de ojos
        const eyeContainers = document.querySelectorAll('.eye-container');
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let isMouseActive = false;
        let idleTimeout;

        const eyeCurrent = [{ x: 0, y: 0 }, { x: 0, y: 0 }];
        let eyeRects = []; // resultados de getBoundingClientRect en caché — se reconstruyen solo al cambiar el tamaño

        function cacheEyeRects() {
            eyeRects = Array.from(eyeContainers).map(c => {
                const r = c.getBoundingClientRect();
                return { cx: r.left + r.width / 2, cy: r.top + r.height / 2 };
            });
        }

        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseActive = true;
            clearTimeout(idleTimeout);
            idleTimeout = setTimeout(() => { isMouseActive = false; }, 2000);
        });

        window.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                isMouseActive = true;
            }
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                isMouseActive = true;
                clearTimeout(idleTimeout);
                idleTimeout = setTimeout(() => { isMouseActive = false; }, 2000);
            }
        }, { passive: true });

        function updateEyes() {
            const time = Date.now();
            eyeContainers.forEach((container, index) => {
                const ball = container.querySelector('.ball');
                if (!ball) return;

                // Usa rectángulos en caché — sin getBoundingClientRect por fotograma
                const ec = eyeRects[index];
                if (!ec) return;
                const eyeCenterX = ec.cx;
                const eyeCenterY = ec.cy;

                let targetX = 0;
                let targetY = 0;

                if (isMouseActive) {
                    let dx = mouseX - eyeCenterX;
                    let dy = mouseY - eyeCenterY;
                    const distance = Math.hypot(dx, dy);
                    const maxTranslate = 20; // movimiento máximo de la pupila
                    const followRadius = Math.min(maxTranslate, distance / 15);
                    const angle = Math.atan2(dy, dx);
                    targetX = Math.cos(angle) * followRadius;
                    targetY = Math.sin(angle) * followRadius;
                } else {
                    // Mirar alrededor lentamente cuando está inactivo
                    const phase = time / 1500 + index * 0.5; // ligero desfase de tiempo por ojo
                    targetX = Math.cos(phase) * 12;
                    targetY = Math.sin(phase * 1.3) * 12;
                }

                // Interpolación suave de la posición de la pupila — 0.15 = seguimiento más rápido
                eyeCurrent[index].x += (targetX - eyeCurrent[index].x) * 0.15;
                eyeCurrent[index].y += (targetY - eyeCurrent[index].y) * 0.15;

                // Ajusta el vector de traslación para compensar las rotaciones de los elementos padre
                const containerRotation = index === 0 ? 30 : -30;
                const eyeRotation = 45;
                const totalRotationRad = (containerRotation + eyeRotation) * Math.PI / 180;

                // Rota la traslación en espacio de pantalla al espacio local sin rotar
                const localX = eyeCurrent[index].x * Math.cos(-totalRotationRad) - eyeCurrent[index].y * Math.sin(-totalRotationRad);
                const localY = eyeCurrent[index].x * Math.sin(-totalRotationRad) + eyeCurrent[index].y * Math.cos(-totalRotationRad);

                // Aplica la transformación (contrarrota para mantener la rendija perfectamente vertical)
                const counterRotation = -(containerRotation + eyeRotation);
                ball.style.transform = `translate(${localX}px, ${localY}px) rotate(${counterRotation}deg)`;
            });
        }

        function resize() {
            width = embersCanvas.width = window.innerWidth;
            height = embersCanvas.height = window.innerHeight;
            cacheEyeRects();
        }
        window.addEventListener('resize', resize);
        resize();

        // Lógica de brasas (embers) flotantes
        class EmberParticle {
            constructor(initial = false) {
                this.reset(initial);
            }

            reset(initial = false) {
                this.x = Math.random() * width;
                this.y = initial ? Math.random() * height : height + 10 + Math.random() * 50;
                this.size = Math.random() * 2 + 0.5;
                this.vy = -(Math.random() * 1.5 + 0.5);
                this.vx = (Math.random() - 0.5) * 1.5;
                this.alpha = Math.random() * 0.8 + 0.2;
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = Math.random() * 0.05 + 0.02;
                const hue = Math.floor(Math.random() * 30) + 10;
                this.color = `hsla(${hue}, 100%, 60%, ${this.alpha})`;
            }

            update() {
                this.y += this.vy;
                this.wobblePhase += this.wobbleSpeed;
                this.x += Math.sin(this.wobblePhase) * 0.8 + this.vx;
                this.size -= 0.005;

                if (this.y < -10 || this.size <= 0) {
                    this.reset();
                }
            }

            draw() {
                if (this.size <= 0) return;

                const relativeHeight = Math.max(0, this.y / height);
                const currentAlpha = relativeHeight * this.alpha;

                embersCtx.globalAlpha = currentAlpha;
                embersCtx.fillStyle = this.color;

                // Brasa principal
                embersCtx.beginPath();
                embersCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                embersCtx.fill();

                // Resplandor falso simulado (muchísimo más rápido que shadowBlur)
                if (this.size > 1.5) {
                    embersCtx.globalAlpha = currentAlpha * 0.3;
                    embersCtx.beginPath();
                    embersCtx.arc(this.x, this.y, this.size * 2.5, 0, Math.PI * 2);
                    embersCtx.fill();
                }
            }
        }

        function init() {
            embersParticles = [];
            for (let i = 0; i < embersCount; i++) {
                embersParticles.push(new EmberParticle(true));
            }
        }

        function animate() {
            frameCount++;
            embersCtx.clearRect(0, 0, width, height);
            embersCtx.globalAlpha = 1;

            if (frameCount % 3 === 0) updateEyes();

            embersCtx.globalCompositeOperation = "lighter";
            embersParticles.forEach(ember => {
                ember.update();
                ember.draw();
            });
            embersCtx.globalCompositeOperation = "source-over";
        }

        // Inicia el bucle inmediatamente para el mejor rendimiento percibido
        init();
        cacheEyeRects();
        requestAnimationFrame(loop);

        // Manejadores de carga individuales para recursos pesados
        const logoImg = document.getElementById('logo');
        const eyesWrapper = document.querySelector('.eyes-wrapper');

        function triggerEyes() {
            // Espera 1 segundo tras la aparición del logo para que los ojos aparezcan después
            setTimeout(() => {
                eyesWrapper.classList.add('animate');
                // Recalcula los rectángulos ahora que los ojos están en su posición final
                cacheEyeRects();
            }, 1000);
        }

        if (logoImg.complete) {
            logoImg.classList.add('loaded');
            triggerEyes();
        } else {
            logoImg.addEventListener('load', () => {
                logoImg.classList.add('loaded');
                triggerEyes();
            });
        }

        const abyssBg = document.querySelector('.abyss-bg');
        const abyssImg = new Image();
        abyssImg.src = 'dark_bg.png';
        if (abyssImg.complete) {
            abyssBg.classList.add('loaded');
        } else {
            abyssImg.addEventListener('load', () => abyssBg.classList.add('loaded'));
        }

        function loop(timestamp) {
            requestAnimationFrame(loop);
            // Límite de 30fps: saltar fotograma si han pasado menos de ~33ms
            if (timestamp - lastFrameTime < FRAME_MS) return;
            lastFrameTime = timestamp;
            animate();
        }
    </script>
</body>

</html>